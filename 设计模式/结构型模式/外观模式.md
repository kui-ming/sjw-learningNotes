# 【设计模式】外观模式（Facade Pattern）

> 外观模式属于**结构型模式**，主要解决客户程序访问复杂程序中的**多个子程序**而产生的**高耦合度**及**高复杂度**问题，根本目的在于**简化接口的调用**。例如我们去医院看病，可能要去挂号、门诊、划价、取药（**子系统角色**），这让患者或患者家属（**客户程序**）觉得很复杂，如果有提供接待人员（**外观角色**），只让接待人员来处理，就很方便。



[TOC]

## 外观模式的介绍

​		**外观模式**也被称作**门面模式**，作用是将**客户程序与一组子系统进行解耦**，使得客户程序只需要与**一个外观类**打交道，而不需要与**多个子系统**类打交道。原理是定义一个**单一类（外观类）**来处理客户程序需要调用的**多个功能类（子系统类）**，此时**客户程序**只需要**调用该单一类**即可完成对多个子系统的调用。



### 优点

- 将程序程序与子系统分隔，减少系统的互相依赖，降低了系统的耦合性
- 系统的修改对其他子系统没有影响，而且子系统内部变化也不会影响外观对象，提高了灵活性
- 操作都在外观类中封装完毕，提高了调用的安全性
- 唯一入口，只提供了一个访问子系统的唯一入口，但不会影响客户程序直接使用子系统类

### 缺点

- 不符合开闭原则，如果设计不当，增加新的子系统可能需要修改外观类，继承重写都不合适

- 不能限制客户程序使用子系统，外观模式不能很好地限制客户程序直接使用子系统，如果客户程序对访问子系统做太多的限制就会减少可变性与灵活性

### 应用场景

- 当要为访问一系列复杂的子系统提供一个简单的入口时
- 层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度，其中三层架构就是这样的一个例子

### 注意事项

- **外观单例**：很多情况下为了节约系统资源，系统只需要一个外观类的实例，也就是**外观类可以是一个单例类**，这样可以降低系统资源的消耗
- **多个外观类**：客户程序可以针对抽象外观类进行编程，在抽象外观类下可以设计多个外观子类，每个外观类负责和一些特定子对象交互，向客户程序提供相应业务功能
- **不要通过外观类增加新行为**：外观模式的意图是为子系统提供一个集中简化的沟通渠道，而不是向子系统中增加新行为，新行为的增加应该通过修改原有子系统类或增加新的子系统类来实现而不是通过外观类实现



## 外观模式的使用

​		举例，每天下班回家的我还需要收拾家务，如扫地、拖地、抹尘、烧水等（子系统类），这让我不胜其烦，于是我决定开发一个机器人来帮我解决这些琐事，以后回家，点击机器人的“收拾家务”按钮就能让它自动收拾家务，岂不快哉。

### 类图

![image-20221205203050059](../../../MDimages/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F_images/image-20221205203050059.png)

#### 两种角色

- **外观角色（Facade）**：此角色中可以知道相关的一个或多个子系统的功能和责任，正常情况下将来自客户程序的请求委派到对应的子系统中去，传递给相应的子系统对象处理。
- **子系统角色（SubSystem）**：每一个子系统可以是一个单独的类，也可以是一个功能模块。每一个子系统都可以被客户程序直接调用，或者被外观角色调用。子系统并不知道外观类的存在，对于子系统而已，外观角色仅仅是另一个客户程序。



### 实现方法

#### 第一步，编写子系统

**扫地功能类**

```java
package 设计模式.结构型模式.外观模式;

public class 扫地功能类 {
    public void 开始(){
        System.out.println("开始扫地……扫地完成！");
    }
}
```

**拖地功能类**

```java
package 设计模式.结构型模式.外观模式;

public class 拖地功能类 {
    public void 开始(){
        System.out.println("开始拖地……拖地完成！");
    }
}
```

**抹尘功能类**

```java
package 设计模式.结构型模式.外观模式;

public class 抹尘功能类 {
    public void 开始(){
        System.out.println("开始抹尘……抹尘完成！");
    }
}
```

**烧水功能类**

```java
package 设计模式.结构型模式.外观模式;

public class 烧水功能类 {
    public void 开始(){
        System.out.println("开始烧水……水还有一阵子才开，先去干其他事吧！");
		// 延时操作
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000); // 等待一秒
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("水开了！");
            }
        }).start();
    }
}
```



#### 第二步，编写外观类

**机器人类**

```java
package 设计模式.结构型模式.外观模式;

/**
 * 外观角色（Facade）
 * 客户程序自己委托该类来调用一系列子功能
 */
public class 机器人类 {

    // 客户程序通过调用该方法来间接的与一组子功能通信
    public void 收拾家务(){
        // 先把水烧上
        new 烧水功能类().开始();
        // 再扫地
        new 扫地功能类().开始();
        // 然后拖地
        new 拖地功能类().开始();
        // 最后抹尘
        new 抹尘功能类().开始();
    }
}
```



#### 第三步，编写测试类测试

**测试类**

```java
package 设计模式.结构型模式.外观模式;

public class 测试类 {
    public static void main(String[] args) {
        // 回到家看到我的机器人
        机器人类 机器人 = new 机器人类();
        // 点击“收拾家务”按钮
        机器人.收拾家务();
    }
}
```

**测试结果**

```shell
开始烧水……水还有一阵子才开，先去干其他事吧！
开始扫地……扫地完成！
开始拖地……拖地完成！
开始抹尘……抹尘完成！
水开了！
Process finished with exit code 0
```

![image-20221205205446980](../../../MDimages/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F_images/image-20221205205446980.png)



### 未使用外观模式的结构

不使用外观类，客户程序直接调用各个功能

#### 修改测试类测试

**测试类**

```java
package 设计模式.结构型模式.外观模式;

public class 测试类 {
    public static void main(String[] args) {
        // 回家先把水烧上
        new 烧水功能类().开始();
        // 再扫地
        new 扫地功能类().开始();
        // 然后拖地
        new 拖地功能类().开始();
        // 最后抹尘
        new 抹尘功能类().开始();
    }
}
```

**测试结果**

![image-20221205205446980](../../../MDimages/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F_images/image-20221205205446980.png)



## 本文参考

[设计模式学习笔记（十三）：外观模式(知乎)](https://zhuanlan.zhihu.com/p/164339604)

[设计模式详解——外观模式(知乎)](https://zhuanlan.zhihu.com/p/421998619)

[外观模式(菜鸟教程)](https://www.runoob.com/design-pattern/facade-pattern.html)
