### MySQL的存储引擎

##### MyISAM（MySQL Indexed Sequential Access Method）

MySQL5.5之前的默认引擎，具有高效的**读取**和**查询**性能，但只**支持表级锁**，**不支持行级锁、事务和外键**，崩溃后无法安全恢复。

特点：

- **适合读密集型应用**：`MyISAM`存储引擎在数据读取方面具有优异的性能，特别是在大量的全表扫描操作中表现得更好。
- **支持全文搜索**：MyISAM 存储引擎支持全文索引和全文搜索，可以提高搜索效率。
- **不支持事务和外键约束**：MyISAM 存储引擎不支持事务和外键约束，因此适合一些对数据完整性和一致性要求不高的应用场景。
- **不支持行级锁**：无法进行行级锁定。这意味着在并发写入时容易出现数据不一致的情况。



使用MyISAM引擎需要注意：

- **使用合适的索引**：在 `MyISAM` 存储引擎中，**索引的使用对查询性能的影响非常大**，因此需要根据实际情况选择合适的索引策略。
- **定期进行优化**：由于 `MyISAM` 存储引擎在写入和更新操作上表现不佳，因此需要定期进行表的优化和修复操作。



应用场景：

- **网站的搜索功能**：MyISAM 存储引擎支持全文索引，可以提高搜索的效率。
- **数据仓库**：MyISAM 存储引擎支持高速的全表扫描，适用于一些只进行数据读取的数据仓库场景。
- **其他**：对事务的完整性没有要求，以查询和插入为主的应用。



**数据文件结构：**

- **表名.frm** ：存储表结构(MySQL8中为 表名.sdi)。
- **表名.MYD** ：MYData，存储数据。
- **表名.MYI** ：MYIndex，存储索引。



##### InnoDB

`InnoDB` 存储引擎是MySQL5.5及以上版本的默认引擎，它支持**事务**、行级锁和**外键约束**等特性。



特点：

- **支持外键约束**：`InnoDB` 存储引擎支持外键约束，可以保证数据的完整性。
- **支持MVCC**：`InnoDB` 存储引擎支持**多版本并发控制** (MVCC) 技术，可以提高并发读取的效率。
- **支持热备份**：`InnoD`B 存储引擎支持热备份，可以在不停止数据库服务的情况下进行备份。
- **适合高并发的写入应用**：`InnoDB` 存储引擎支持事务处理和行级锁定，可以保证数据的一致性，因此适合高并发的写入应用。



使用InnoDB引擎需要注意：

- **合理设置缓冲池**：在 `InnoDB` 存储引擎中，缓冲池是一个重要的性能参数，需要根据实际情况进行合理设置。
- **注意事务的隔离级别**：`InnoDB` 存储引擎支持多种事务隔离级别，应根据业务需求选择合适的隔离级别。
- **控制锁的粒度**：在 `InnoDB` 存储引擎中，锁对并发性能影响较大，因此需要控制锁的粒度，尽可能使用行级锁。
- **定期进行维护**：由于 `InnoDB` 存储引擎会产生大量的磁盘碎片，因此需要定期进行表的优化和修复操作。



应用场景：

- **电商网站**：电商网站的订单管理系统需要支持高并发的写入和更新操作，并且需要保证事务的一致性，因此适合使用 `InnoDB` 存储引擎。
- **博客网站**：博客网站需要支持评论的功能，因此需要使用外键约束来保证数据的完整性和一致性，适合使用 `InnoDB` 存储引擎。
- **金融系统**：金融系统需要保证数据的安全性和一致性，需要支持事务的功能，适合使用 `InnoDB` 存储引擎。



**数据文件结构**：

- **表名.frm** ：存储表结构（MySQL8时合并在 表名.ibd 中）。
- **表名.ibd** ：存储数据和索引。





### MySQL的索引

​		在数据库中，索引是一种特殊的数据结构，用于**加速查询**操作。它是数据库中一组**数据的指针**，可以帮助数据库系统**快速地定位**到某些数据的存储位置，从而提高查询速度。索引可以提高查询速度，但也会**占用一定的存储空间**和**增加写入数据的时间成本**，因此在设计索引时需要考虑到数据库的实际情况和应用场景。



常见的设计索引的原则包括：

1. 对经常查询的字段建立索引；
2. 对于查询的结果集较小的字段，不建议建立索引；
3. 对于数据量较大的表，应该避免建立过多的索引；
4. 对于经常修改的表，应该谨慎使用索引，因为索引的维护会增加修改操作的时间成本。

需要注意的是，索引的设计和使用需要结合具体的业务需求和查询情况进行优化和调整，以达到最优的性能和效果。



#### MySQL的索引分类
1.  **普通索引**：最常见的索引类型，用于加速被索引字段的等值查询、范围查询及排序操作。
2. **唯一索引**：与普通索引类似，不同的是次索引列的值不可重复，必须是唯一的，但允许空值。存在多个索引列时，这些列的组合值必须唯一。
3. **主键索引**：它是一种特殊的唯一索引，用于唯一标识表中的一条数据，不允许空值，一般使用`primary key`关键字来约束。
4. **复合索引**：它是包含多个字段的索引类型，用于加速对多个字段进行查询操作。
5. **全文索引**：用于加速对文本字段的全文搜索及关键字的查询。MyISAM引擎支持全文索引，InnoDB在MySQL5.6后支持全文索引，默认MySQL不支持中文检索。



##### 复合索引的创建有哪些讲究



1. **字段的顺序**：复合索引中的字段顺序应该根据字段的**选择性**(过滤数据行多)和**经常性**(查询次数多)来确定。**查询次数多的字段放前面**可以减少索引扫描次数。同时，**选择性高的字段应当靠前**，低的靠后。
1. **字段的类型**：复合索引中的**列数据类型要尽可能小**。因为 `MySQL` 在使用复合索引进行查询时，需要对索引列进行排序和比较操作，数据类型越大，比较操作的耗时就越长。
1. **字段的数量**：一个复合索引最好**不超过5个索引列**。
1. **字段的选择**：选择**经常性高**和**选择性高**的字段，尽量不要选择无意义的字段（如性别列）。
1. **字段的重复使用**：如果一个索引字段**已存在于另一个索引**中，那么在创建复合索引时**不用考虑**它。



**经常性**：指一个查询条件在实际应用中被使用的频率。经常性越高，表示该查询条件被使用的频率越高。

**选择性**：选择性高的查询条件可以更快地过滤掉不符合条件的数据行，减少需要扫描的数据行数量。如查询用户ID为“123”的数据行肯定比查询用户性别为“男”的选择性高。



##### 全文索引不支持中文检索怎么办

​		中文由多个字组成一个词语，而全文索引默认只能按单词匹配。如果需要支持中文检索，可以使用全文检索插件中的中文分词器，将中文文本进行分词后再进行索引。

​		在 MySQL 中，可以使用第三方插件如 `Sphinx`、`Lucene` 等来实现中文全文检索。同时也可以使用 MySQL 内置的全文检索功能，MySQL 5.7 版本以后提供了 InnoDB 存储引擎的全文索引，可以在中文检索时使用 `ngram` 分词器来进行中文分词，支持中文检索。

​		此外，如果需要更加精确的中文检索，也可以使用专业的中文分词器如中科院计算所的 `ICTCLAS`、哈工大的 `LTP` 等来进行中文分词，然后将分词结果进行索引。这样虽然会增加索引的复杂度和存储空间，但可以提高中文检索的精度和效率。



#### 索引可能失效的场景



**1、非首字段查询（不满足最左匹配原则）**

​		在复合索引中，最左侧的字段优先匹配，如果在**查询条件中，不存在索引中的最左字段**会有**极大可能导致索引失效**或效率不高。

```mysql
#存在复合索引：(p_no,name,age)

explain select * from person where p_no="1002" and name = "张三" and age = 23; # 走索引
explain select * from person where p_no="1002" and age = 23; # 走索引
explain select * from person where p_no="1002" and name = "张三"; # 走索引
explain select * from person where name = "张三" and  p_no="1002"; # 走索引


explain select * from person where name = "张三" and age = 23; # 索引失效
```



**2、使用`select *`查询**

​		使用全字段查询时，会多出额外的负担，浪费资源，并且在多种情况下会导致索引失效，如非首字段查询。如果不使用`*`而是只查询索引列的话，就算是非首字段查询，也因为查询的列为索引列而走**覆盖索引**。

```mysql
#存在复合索引：(p_no,name,age)

explain select * from person where name = "张三" and age = 23; # 索引失效

explain select p_no,name,age from person where name = "张三"; # 走覆盖索引
```





**3、对索引列进行计算或函数处理**

​		将索引字段使用函数或运算符进行处理或计算时会导致索引失效。

```mysql
#存在索引：p_no、age

explain select * from person where age - 1 = 23; # 索引失效
# 修改为
explain select * from person where age = 23 - 1; # 走索引

# 不可使用函数操作索引字段
explain select * from person where SUBSTR(p_no,1,3) = '100'; # 索引失效
```



**4、使用`LIKE`进行模糊查询**

​		**以`“%”`开头**的`LIKE`查询将导致索引失效，因为在这种情况下MySQL无法使用索引进行匹配。

```mysql
#存在索引：p_no

# 如果模糊查询的开头是占位符"%"，索引不会生效，因为索引从左到右逐个排序，而占位符导致索引无法正常匹配
explain select * from person where p_no LIKE '%2'; # 索引失效
explain select * from person where p_no LIKE '%2%'; # 索引失效

explain select * from person where p_no LIKE '100%'; # 可能走索引

# 使用覆盖索引
explain select p_no from person where p_no LIKE '%00%'; # 走索引

```



**5、数据类型不匹配**

​		当**查询条件的数据类型与索引字段的数据类型不匹配**时，MySQL会调用函数进行隐式类型转换，索引将失效。

```mysql
#存在索引：p_no(varchar)、age(int)

explain select * from person where p_no = 1002; # 索引失效

# 特例，当字段类型为int类型，而查询条件添加了单引号或双引号时，MySQL会将参数转为int型，而不转换字段。
explain select * from person where age = "23"; # 走索引
```



**6、使用OR操作**

​		OR查询将使得索引失效，因为OR查询涉及多个条件，MySQL难以使用索引来加速查询。

```mysql
#存在索引：p_no(varchar)、age(int)
# 如果没有为这两列同时创建一个复合索引，那么查询就会导致索引失效
explain select * from person where p_no = "1002" OR age = 23; # 索引失效

#存在索引：(p_no,age)
explain select * from person where p_no = "1002" OR age = 23; # 走索引
```



**7、使用 >、<、 !=、<> 、NOT、IN、NOT IN、NOT LIKE等比较符**

- 使用 `>` 或 `<` 操作符时，如果查询的列上没有建立索引，则会导致全表扫描，索引失效。
- 使用“不等于”（ `!=` 或 `<>` ）操作符时，也可能导致索引失效。因为MySQL优化器在执行查询时可能会认为扫描全表比使用索引更高效，从而放弃使用索引。
- 使用 `NOT`、`NOT IN`、`NOT LIKE` 等操作符时，也可能导致索引失效。这是因为这些操作符会导致MySQL无法使用索引中的“匹配项”进行快速过滤，从而只能扫描全表来获取符合条件的记录。
- 在一些特殊情况下，使用 `IN` 操作符也可能导致索引失效。比如，当使用“IN”操作符查询的值集合非常大时，MySQL可能会认为扫描全表比使用索引更高效，从而放弃使用索引。



**8、NULL值查询**

​		当索引字段包含NULL值时，使用 `IS NOT NULL` 进行查询时，索引将失效。

```mysql
#存在索引：p_no

explain select * from person where p_no IS NULL; # 走索引
explain select * from person where p_no IS NOT NULL; # 索引失效
```



**9、隐式字符编码转换**

​		在使用字符集不同的条件下，索引也可能失效。当两个表之间做关联查询时，如果两个表中关联的字段字符编码不一致的话，MySQL可能会调用 `CONVERT`函数，将不同的字符编码进行隐式转换从而达到统一。作用到关联的字段时，就会导致索引失效。

比如下面这个语句，其中d.tradeid字符编码为 `utf8` ，而l.tradeid的字符编码为 `utf8mb4` 。因为utf8mb4是utf8的超集，所以MySQL在做转换时会用 `CONVERT` 将 `utf8` 转为 `utf8mb4` 。简单来看就是 `CONVERT` 作用到了d.tradeid上，因此索引失效。

```mysql
explain select l.operator from tradelog l , trade_detail d where d.tradeid=l.tradeid and d.id=4;
```



**总结**

- 索引的失效情况是不确定的，考虑到实际数据量等情况，最终是否使用索引还是要看My SQL优化器的判断，它会自动选择最优的情况。
- 如果一定要用索引可以使用 `USE INDEX(index_name)` 或 `FORCE INDEX(index_name)` 来强制使用指定的索引，但可能导致索引变慢。
- 进行SQL优化时，可以在查询语句前使用`explain`关键字 来分析索引使用情况。
- 字段设为not null并提供默认值可以降低MySQL查询及处理的复杂程度。



##### 回表

通过普通索引表只能找到主键ID，还需要再从主键索引表中找到主体数据行，这个二次查找的过程叫做回表。

回表是指在使用索引查询时，当需要查询的数据不在索引上时，需要通过索引中的指针再去表中查找相应的数据的过程。因为索引只包含了一部分数据，而真正的数据存储在表中，所以在某些情况下，查询需要回到表中进行查询，这就是所谓的回表。回表的过程会增加额外的IO操作和查询时间，因此在设计索引时需要尽可能地减少回表的次数。

##### 覆盖索引

需查找的字段已存在索引表中，可以直接返回此数据，无需通过回表再查一遍主体数据。

覆盖索引是指查询语句可以直接通过索引获取到所需的数据，而不需要回表（回到数据表中再去查找数据），因为索引中包含了查询所需的所有数据列，可以直接从索引中获取到所有需要的数据，这种索引也被称为索引包含所有需要查询的列。

相比于非覆盖索引，覆盖索引可以显著地提高查询的效率，因为回表会增加额外的I/O操作和查询时间。另外，由于覆盖索引不需要回表，所以可以减少锁的竞争，提高并发性能。

覆盖索引适用于一些查询非常频繁，但是需要查询的列并不多的场景，比如只需要查询ID、名称、日期等少数几列的查询，可以使用覆盖索引来避免回表操作，提高查询效率。

##### 索引下推

索引下推是一种优化查询性能的技术，原理是将过滤条件下推至存储引擎层面过滤，可以减少存储引擎查询的数据量和访问的块数。索引下推技术是MySQL5.6版本之后引入的。

举个例子，假设有一个表包含两个字段，分别为`id`和`name`，其中`id`字段为主键，`name`字段上有一个普通索引。现在需要查询`name`为“张三”并且`id`大于100的数据：

```mysql
SELECT * FROM table WHERE name = '张三' AND id > 100;
```

在MySQL 5.6版本之前，MySQL只能使用索引扫描，首先根据`name`字段的索引找到所有`name`为“张三”的记录，然后再将这些记录逐条进行过滤，判断`id`是否大于100。这样做的问题是需要扫描索引和数据块，增加了IO操作和CPU计算时间，效率较低。

而在MySQL 5.6版本之后，MySQL引入了索引下推优化，可以将`id`大于100的条件下推到存储引擎层面进行过滤。存储引擎可以通过索引扫描的方式，先根据`name`字段的索引找到第一个`name`为“张三”的记录，然后根据`id`字段的索引往后扫描，直到找到`id`大于100的记录，这样就减少了数据的读取量和访问的块数，提高了查询效率。

需要注意的是，索引下推只对某些类型的查询起作用，如AND、OR等逻辑运算符，而对于IN、LIKE等操作则不一定会起作用。另外，索引下推也会增加CPU的消耗，因此需要根据具体情况进行评估和选择。





### SQL窗口函数

窗口函数又叫OLAP(Online Anallytical Processing,联机分析处理)函数，用于**处理相对复杂的报表统计分析场景**。

#### 基本含义

窗口函数主要作用是限定出一个范围，满足某些条件的记录行集合将存在于这个窗口中，随后再对这个窗口中的数据集合执行函数运算。**MySQL8.0开始支持窗口函数**。



#### 基本语法

窗口函数有`over`关键字，指定其前面函数执行的范围，其中包含三个分析子句：**分组子句**(`partition by`)、**排序子句**(`order by`)、**窗口限定子句**(`rows`)。如果里面子句不写，则规定一个包含满足where条件的所有行的窗口，如果写了，则按照分析子句中的限定规则来定义窗口。

```mysql
<函数名> over(partition by <分组的列> order by <排序的列> rows between <起始行> and <结束行>)
```



##### rows between 限定范围

```mysql
rows between 2 preceding and current row          # 取当前行和前面两行

rows between unbounded preceding and current row  # 取当前行和之前的所有行

rows between current row and 3 following          # 取当前行和之后两行

rows between current row and unbounded following  # 取当前行和之后所有行

rows between 4 preceding and 1 following          # 取从前面4行到之后1行，包括当前行一共5行

```

- 当`order by` 后面缺失窗口限定子句，窗口范围默认是取当前行和前面所有行，`rows between unbounded preceding and current row`；
- 当`order by` 和 `rows between` 都不存在，默认取满足`where`条件的所有行，`rows between unbounded preceding and unbounde following`。



**表名：sql_5**

| cid(班级编号) | name(姓名) | score(成绩) |
| ------------- | ---------- | ----------- |
| 001           | 张三       | 78          |
| 001           | 小明       | 90          |
| 002           | 王五       | 67          |
| 001           | 李四       | 82          |
| 002           | 小红       | 85          |
| 002           | 王刚       | 62          |
| 001           | 赵六       | 78          |
| 002           | 钱七       | 85          |



##### row_number()

查询每个人的信息及在班级中的排名，没有排名相同的情况

```mysql
# 如果出现相同值，排名也无法相同
select *,row_number() over(partition by cid order by score desc) as 班级排名 from sql_5;
```

查询结果

```mysql
cid	sname score 班级排名
001	小明	90	1
001	李四	82	2
001	张三	78	3
001	赵六	78	4
002	小红	85	1
002	钱七	85	2
002	王五	67	3
002	王刚	62  4
```



##### rank()

查询每个人的信息及在班级中的排名，分数相同排名相同，后一名空一位排名

```mysql
# 如果出现相同值，排名也无法相同
select *,row_number() over(partition by cid order by score desc) as 班级排名 from sql_5;
```

查询结果

```mysql
cid	sname score 班级排名
001	小明	90	1
001	李四	82	2
001	张三	78	3
001	赵六	78	3
002	小红	85	1
002	钱七	85	1
002	王五	67	3
002	王刚	62  4
```



##### sum()

查询每个班的总分，从第一名开始累计，每个人显示加上自己分数后的班级总分

```mysql
select *,sum(score) over(partition by cid order by score desc) as 班级总分 from sql_5;
```

查询结果

```mysql
cid	sname score 班级总分
001	小明	90	90
001	李四	82	172
001	张三	78	328
001	赵六	78	328
002	小红	85	170
002	钱七	85	170
002	王五	67	237
002	王刚	62  299
```



##### avg()

查询个人信息，每个人后面加上自己班级的班级平均分，保留小数点后两位

```mysql
# 先使用窗口函数与求平均值函数计算出每个班级的平均值，然后将其作为round函数四舍五入保留两位小数
select *,round(avg(score) over(partition by cid) , 2) 班级平均分 from sql_5;
```

查询结果

```mysql
cid	sname score 班级平均分
001	张三	78	83.33
001	小明	90	83.33
001	李四	82	83.33
002	王五	67	71.33
002	小红	85	71.33
002	王刚	62  71.33
```





